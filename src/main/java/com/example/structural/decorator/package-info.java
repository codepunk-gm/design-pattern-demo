/**
 * 装饰器模式（Decorator Pattern）包
 *
 * 装饰器模式是一种结构型设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构。
 * 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。
 *
 * 主要组成部分：
 * 1. 抽象组件（Component）：定义一个对象接口，可以给这些对象动态添加职责
 * 2. 具体组件（Concrete Component）：定义一个对象，可以给这个对象添加一些职责
 * 3. 抽象装饰器（Decorator）：维持一个指向组件对象的引用，并定义一个与组件接口一致的接口
 * 4. 具体装饰器（Concrete Decorator）：向组件添加职责
 *
 * 适用场景：
 * 1. 需要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
 * 2. 需要动态地给一个对象增加功能，这些功能可以动态地撤销
 * 3. 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时
 * 4. 需要为一批兄弟类进行改装或加装功能时
 *
 * 优点：
 * 1. 装饰类和被装饰类可以独立发展，不会相互耦合
 * 2. 装饰模式是继承的一个替代模式，提供了更加灵活的扩展功能
 * 3. 可以动态地扩展一个实现类的功能
 * 4. 通过使用不同的装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合
 *
 * 注意事项：
 * 1. 装饰器模式会增加许多小对象，如果过度使用，会让程序变得复杂
 * 2. 装饰器模式易于出错，调试排查比较困难
 * 3. 装饰器模式的使用需要注意顺序，不同的装饰顺序可能会导致不同的结果
 *
 * 本包中的示例通过咖啡订单系统展示了装饰器模式的实现：
 * - Coffee：抽象组件，定义咖啡的基本特性
 * - SimpleCoffee：具体组件，实现基础咖啡
 * - CoffeeDecorator：抽象装饰器，定义装饰者的通用行为
 * - MilkDecorator：具体装饰器，为咖啡添加牛奶
 */
package com.example.structural.decorator;